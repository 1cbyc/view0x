import {
  Model,
  DataTypes,
  CreationOptional,
  InferAttributes,
  InferCreationAttributes,
  ForeignKey,
  BelongsToAssociation,
} from "sequelize";
import { sequelize } from "../config/database";
import { Analysis } from "./Analysis";

export class Vulnerability extends Model<
  InferAttributes<Vulnerability>,
  InferCreationAttributes<Vulnerability>
> {
  declare id: CreationOptional<string>;
  declare analysisId: ForeignKey<Analysis["id"]>;
  declare type: string;
  declare severity: "HIGH" | "MEDIUM" | "LOW";
  declare title: string;
  declare description: string;
  declare location: object;
  declare recommendation: string;
  declare source: "slither" | "solhint" | "mythx" | "custom";
  declare confidence: CreationOptional<"HIGH" | "MEDIUM" | "LOW">;
  declare impact: CreationOptional<"HIGH" | "MEDIUM" | "LOW">;
  declare cweId: CreationOptional<number>;
  declare gasImpact: CreationOptional<number>;
  declare lineStart: CreationOptional<number>;
  declare lineEnd: CreationOptional<number>;
  declare columnStart: CreationOptional<number>;
  declare columnEnd: CreationOptional<number>;
  declare functionName: CreationOptional<string>;
  declare contractName: CreationOptional<string>;
  declare fixed: CreationOptional<boolean>;
  declare falsePositive: CreationOptional<boolean>;
  declare notes: CreationOptional<string>;
  declare createdAt: CreationOptional<Date>;
  declare updatedAt: CreationOptional<Date>;

  // Associations
  declare analysis?: Analysis;
  declare static associations: {
    analysis: BelongsToAssociation<Vulnerability, Analysis>;
  };

  // Instance methods
  getSeverityScore(): number {
    switch (this.severity) {
      case "HIGH":
        return 10;
      case "MEDIUM":
        return 5;
      case "LOW":
        return 1;
      default:
        return 0;
    }
  }

  getConfidenceScore(): number {
    switch (this.confidence) {
      case "HIGH":
        return 10;
      case "MEDIUM":
        return 5;
      case "LOW":
        return 1;
      default:
        return 5; // Default to medium confidence
    }
  }

  getImpactScore(): number {
    switch (this.impact) {
      case "HIGH":
        return 10;
      case "MEDIUM":
        return 5;
      case "LOW":
        return 1;
      default:
        return 5; // Default to medium impact
    }
  }

  getRiskScore(): number {
    return (this.getSeverityScore() + this.getConfidenceScore() + this.getImpactScore()) / 3;
  }

  getSeverityEmoji(): string {
    switch (this.severity) {
      case "HIGH":
        return "üî¥";
      case "MEDIUM":
        return "üü°";
      case "LOW":
        return "üü¢";
      default:
        return "‚ö™";
    }
  }

  getSourceIcon(): string {
    switch (this.source) {
      case "slither":
        return "üêç";
      case "solhint":
        return "üìè";
      case "mythx":
        return "üîÆ";
      case "custom":
        return "üîß";
      default:
        return "‚ùì";
    }
  }

  markAsFixed(notes?: string): Promise<Vulnerability> {
    this.fixed = true;
    if (notes) {
      this.notes = notes;
    }
    return this.save();
  }

  markAsFalsePositive(notes?: string): Promise<Vulnerability> {
    this.falsePositive = true;
    if (notes) {
      this.notes = notes;
    }
    return this.save();
  }

  toSummary() {
    return {
      id: this.id,
      type: this.type,
      severity: this.severity,
      title: this.title,
      source: this.source,
      confidence: this.confidence,
      impact: this.impact,
      riskScore: this.getRiskScore(),
      fixed: this.fixed,
      falsePositive: this.falsePositive,
      location: {
        lineStart: this.lineStart,
        lineEnd: this.lineEnd,
        functionName: this.functionName,
      },
    };
  }

  // Static methods
  static async findByAnalysis(analysisId: string): Promise<Vulnerability[]> {
    return this.findAll({
      where: { analysisId },
      order: [
        ["severity", "DESC"], // HIGH first
        ["confidence", "DESC"],
        ["impact", "DESC"],
      ],
    });
  }

  static async findBySeverity(
    severity: "HIGH" | "MEDIUM" | "LOW",
    options?: {
      limit?: number;
      analysisId?: string;
    }
  ): Promise<Vulnerability[]> {
    const where: any = { severity };

    if (options?.analysisId) {
      where.analysisId = options.analysisId;
    }

    return this.findAll({
      where,
      limit: options?.limit,
      order: [["createdAt", "DESC"]],
    });
  }

  static async findByType(
    type: string,
    options?: {
      limit?: number;
      analysisId?: string;
    }
  ): Promise<Vulnerability[]> {
    const where: any = { type };

    if (options?.analysisId) {
      where.analysisId = options.analysisId;
    }

    return this.findAll({
      where,
      limit: options?.limit,
      order: [["createdAt", "DESC"]],
    });
  }

  static async getTypeStatistics(analysisId?: string) {
    const where: any = {};
    if (analysisId) {
      where.analysisId = analysisId;
    }

    const vulnerabilities = await this.findAll({
      where,
      attributes: ["type", "severity", "source"],
    });

    const typeStats: Record<string, {
      count: number;
      severityBreakdown: Record<string, number>;
      sourceBreakdown: Record<string, number>;
    }> = {};

    vulnerabilities.forEach(vuln => {
      if (!typeStats[vuln.type]) {
        typeStats[vuln.type] = {
          count: 0,
          severityBreakdown: { HIGH: 0, MEDIUM: 0, LOW: 0 },
          sourceBreakdown: { slither: 0, solhint: 0, mythx: 0, custom: 0 },
        };
      }

      typeStats[vuln.type].count++;
      typeStats[vuln.type].severityBreakdown[vuln.severity]++;
      typeStats[vuln.type].sourceBreakdown[vuln.source]++;
    });

    return typeStats;
  }

  static async getSeverityStatistics(analysisId?: string) {
    const where: any = {};
    if (analysisId) {
      where.analysisId = analysisId;
    }

    const result = await this.findAll({
      where,
      attributes: [
        "severity",
        [sequelize.fn("COUNT", sequelize.col("id")), "count"],
      ],
      group: ["severity"],
      raw: true,
    });

    const stats = {
      HIGH: 0,
      MEDIUM: 0,
      LOW: 0,
      total: 0,
    };

    result.forEach((row: any) => {
      stats[row.severity as keyof typeof stats] = parseInt(row.count);
      stats.total += parseInt(row.count);
    });

    return stats;
  }

  static async getMostCommonVulnerabilities(limit: number = 10) {
    const result = await this.findAll({
      attributes: [
        "type",
        [sequelize.fn("COUNT", sequelize.col("id")), "count"],
        [sequelize.fn("AVG",
          sequelize.literal(`CASE
            WHEN severity = 'HIGH' THEN 10
            WHEN severity = 'MEDIUM' THEN 5
            ELSE 1
          END`)
        ), "avgSeverity"],
      ],
      group: ["type"],
      order: [[sequelize.literal("count"), "DESC"]],
      limit,
      raw: true,
    });

    return result.map((row: any) => ({
      type: row.type,
      count: parseInt(row.count),
      averageSeverity: parseFloat(row.avgSeverity).toFixed(1),
    }));
  }

  static async bulkCreateFromAnalysisResult(
    analysisId: string,
    vulnerabilities: any[]
  ): Promise<Vulnerability[]> {
    const vulnerabilityData = vulnerabilities.map(vuln => ({
      analysisId,
      type: vuln.type,
      severity: vuln.severity,
      title: vuln.title,
      description: vuln.description,
      location: vuln.location,
      recommendation: vuln.recommendation,
      source: vuln.source || "slither",
      confidence: vuln.confidence,
      impact: vuln.impact,
      cweId: vuln.cweId,
      gasImpact: vuln.gasImpact,
      lineStart: vuln.location?.line || vuln.location?.start,
      lineEnd: vuln.location?.lineEnd || vuln.location?.end,
      columnStart: vuln.location?.column,
      columnEnd: vuln.location?.columnEnd,
      functionName: vuln.functionName,
      contractName: vuln.contractName,
    }));

    return this.bulkCreate(vulnerabilityData, {
      validate: true,
      returning: true,
    });
  }

  static getVulnerabilityCategories() {
    return {
      "Access Control": [
        "unprotected-upgrade",
        "missing-zero-check",
        "unprotected-selfdestruct",
        "arbitrary-send",
        "controlled-delegatecall",
      ],
      "Reentrancy": [
        "reentrancy-eth",
        "reentrancy-no-eth",
        "reentrancy-benign",
        "reentrancy-events",
      ],
      "Gas Optimization": [
        "gas-loop",
        "gas-struct-packing",
        "gas-unused-return",
        "gas-cache-array-length",
      ],
      "Code Quality": [
        "dead-code",
        "similar-names",
        "too-many-digits",
        "costly-loop",
      ],
      "Best Practices": [
        "pragma",
        "solc-version",
        "naming-convention",
        "unused-state",
      ],
      "Security": [
        "weak-prng",
        "block-timestamp",
        "tx-origin",
        "unchecked-lowlevel",
      ],
    };
  }
}

Vulnerability.init(
  {
    id: {
      type: DataTypes.UUID,
      defaultValue: DataTypes.UUIDV4,
      primaryKey: true,
    },
    analysisId: {
      type: DataTypes.UUID,
      allowNull: false,
      references: {
        model: Analysis,
        key: "id",
      },
      onDelete: "CASCADE",
      onUpdate: "CASCADE",
    },
    type: {
      type: DataTypes.STRING,
      allowNull: false,
      validate: {
        notEmpty: true,
        len: [1, 100],
      },
    },
    severity: {
      type: DataTypes.ENUM("HIGH", "MEDIUM", "LOW"),
      allowNull: false,
    },
    title: {
      type: DataTypes.STRING,
      allowNull: false,
      validate: {
        notEmpty: true,
        len: [1, 255],
      },
    },
    description: {
      type: DataTypes.TEXT,
      allowNull: false,
      validate: {
        notEmpty: true,
      },
    },
    location: {
      type: DataTypes.JSONB,
      allowNull: false,
      validate: {
        isValidLocation(value: any) {
          if (typeof value !== "object" || value === null) {
            throw new Error("Location must be a valid JSON object");
          }
          if (typeof value.start !== "number" || typeof value.end !== "number") {
            throw new Error("Location must have numeric start and end properties");
          }
        },
      },
    },
    recommendation: {
      type: DataTypes.TEXT,
      allowNull: false,
      validate: {
        notEmpty: true,
      },
    },
    source: {
      type: DataTypes.ENUM("slither", "solhint", "mythx", "custom"),
      allowNull: false,
      defaultValue: "slither",
    },
    confidence: {
      type: DataTypes.ENUM("HIGH", "MEDIUM", "LOW"),
      defaultValue: "MEDIUM",
    },
    impact: {
      type: DataTypes.ENUM("HIGH", "MEDIUM", "LOW"),
      defaultValue: "MEDIUM",
    },
    cweId: {
      type: DataTypes.INTEGER,
      validate: {
        min: 1,
        max: 9999,
      },
    },
    gasImpact: {
      type: DataTypes.INTEGER,
      validate: {
        min: 0,
      },
    },
    lineStart: {
      type: DataTypes.INTEGER,
      validate: {
        min: 1,
      },
    },
    lineEnd: {
      type: DataTypes.INTEGER,
      validate: {
        min: 1,
      },
    },
    columnStart: {
      type: DataTypes.INTEGER,
      validate: {
        min: 1,
      },
    },
    columnEnd: {
      type: DataTypes.INTEGER,
      validate: {
        min: 1,
      },
    },
    functionName: {
      type: DataTypes.STRING,
      validate: {
        len: [0, 100],
      },
    },
    contractName: {
      type: DataTypes.STRING,
      validate: {
        len: [0, 100],
      },
    },
    fixed: {
      type: DataTypes.BOOLEAN,
      defaultValue: false,
    },
    falsePositive: {
      type: DataTypes.BOOLEAN,
      defaultValue: false,
    },
    notes: {
      type: DataTypes.TEXT,
    },
    createdAt: {
      type: DataTypes.DATE,
      allowNull: false,
      defaultValue: DataTypes.NOW,
    },
    updatedAt: {
      type: DataTypes.DATE,
      allowNull: false,
      defaultValue: DataTypes.NOW,
    },
  },
  {
    sequelize,
    tableName: "vulnerabilities",
    timestamps: true,
    indexes: [
      {
        fields: ["analysis_id"],
      },
      {
        fields: ["type"],
      },
      {
        fields: ["severity"],
      },
      {
        fields: ["source"],
      },
      {
        fields: ["analysis_id", "severity"],
      },
      {
        fields: ["type", "severity"],
      },
      {
        fields: ["fixed"],
      },
      {
        fields: ["false_positive"],
      },
      {
        fields: ["created_at"],
      },
    ],
    scopes: {
      highSeverity: {
        where: { severity: "HIGH" },
      },
      mediumSeverity: {
        where: { severity: "MEDIUM" },
      },
      lowSeverity: {
        where: { severity: "LOW" },
      },
      unfixed: {
        where: { fixed: false },
      },
      genuine: {
        where: { falsePositive: false },
      },
      bySource: (source: "slither" | "solhint" | "mythx" | "custom") => ({
        where: { source },
      }),
      withAnalysis: {
        include: [
          {
            model: Analysis,
            as: "analysis",
            attributes: ["id", "contractName", "createdAt"],
          },
        ],
      },
    },
  }
);

// Define associations
Vulnerability.belongsTo(Analysis, {
  foreignKey: "analysisId",
  as: "analysis",
});

Analysis.hasMany(Vulnerability, {
  foreignKey: "analysisId",
  as: "vulnerabilities",
});
